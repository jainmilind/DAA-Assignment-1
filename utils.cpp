#include <cassert>
#include <cstddef>
#include <vector>
#include <set>
#include <queue>
#include <limits.h>
#include <array>
#include <math.h>

/**
 * This function is used to calculate the angle in degrees formed between 3 verticles in the anti-clockwise direction with pivot as the middle vertex.
 * @param a This is the first vertex.
 * @param b This is vertex which is the pivot.
 * @param c This is the final vertex.
 * @return It returns the angle which is in degrees.
 */
double angle(Vertex *a, Vertex *b, Vertex *c)
{
    double angle1 = atan2(b->y - a->y, b->x - a->x);
    double angle2 = atan2(c->y - b->y, c->x - b->x);
    double angle = angle2 - angle1;
    if (angle > M_PI)
        angle -= 2 * M_PI;
    else if (angle <= -M_PI)
        angle += 2 * M_PI;
    return angle * 180 / M_PI + 180;
}

/**
 * This function is used to check if the given angle at a vertex is convex or not.
 * @param v This is the first vertex.
 * @return It returns true if at the given vertex is an convex angle else it returns false.
 */
bool is_convex_angle(Vertex *v)
{
    bool ans = true;
    Vertex *prev = v->leave->nxt->org;
    Vertex *nxt = v->leave->prev->org;

    return angle(prev, v, nxt) <= 180;
}

const double inf = (double)INT64_MAX; /*!< For storing the maximum possible value of int data type */

/**
 * This function returns a rectangle that is the smallest rectangle enclosing all the veritices provided as input.
 * @param vertices This is a vector of vertices.
 * @return It returns the final rectangle.
 */
Rectangle get_rectangle(std::vector<Vertex *> &vertices)
{
    Rectangle ans = Rectangle(inf, inf, -inf, -inf);
    for (Vertex *v : vertices)
    {
        ans.ux = std::max(ans.ux, v->x);
        ans.uy = std::max(ans.uy, v->y);

        ans.lx = std::min(ans.lx, v->x);
        ans.ly = std::min(ans.ly, v->y);
    }

    return ans;
}

/**
 * This function is used to check if a particular point is present in the rectangle.
 * @param v This is vertex that we are checking.
 * @param rectangle This is the rectangle that we are checking if the vertex is present inside.
 * @return It returns true if vertex is present in the rectangle and false if it doesnt.
 */
bool is_inside_rectangle(Rectangle &rectangle, Vertex *v)
{
    return v->x > rectangle.lx and v->x < rectangle.ux and v->y > rectangle.ly and v->y < rectangle.uy;
}

/**
 * This function is used to check if a particular point is present a polygon generated by the given set of vertices.
 * @param v This is vertex we are checking.
 * @param polygon This is vector of vertices of the polygon.
 * @return It returns true if vertex is present in the polygon and false if it doesnt.
 */
bool is_inside_polygon(std::vector<Vertex *> &polygon, Vertex *v)
{
    int n = polygon.size();
    int i = 0, j = 0;
    bool answer = false;
    for (i = 0, j = n - 1; i < n; j = i++)
    {
        double xi = polygon[i]->x, yi = polygon[i]->y, xj = polygon[j]->x, yj = polygon[j]->y;
        if (((yi > v->y) != (yj > v->y)) and (v->x < (xj - xi) * (v->y - yi) / (yj - yi) + xi))
            answer ^= 1;
    }
    return answer;
}

/**
 * This function is used to get the line between two vertices, it returns an array having the coefficients of the line.
 * @param v1 This is the first vertex.
 * @param v2 This is the second vertex.
 * @return It returns an array of coefficients a,b,c if the line is of the form ax+by=c.
 */
std::array<double, 3> findLine(Vertex *v1, Vertex *v2)
{
    double a = v2->y - v1->y;
    double b = v1->x - v2->x;
    double c = a * (v1->x) + b * (v1->y);
    return {a, b, c};
}

/**
 * This function is used to check if two points a and b lie on the same side of the line formed by joining vertex v1 and vertex v2.
 * @param v1 This is the first vertex for the line.
 * @param v2 This is the second vertex for the line.
 * @param a This is the first vertex we check.
 * @param b This is the second vertex we check.
 * @return It returns true if both the points a and b are on the same side of the line else it returns false.
 */
bool onSameSide(Vertex *v1, Vertex *v2, Vertex *a, Vertex *b)
{
    std::array<double, 3> coeff = findLine(v1, v2);
    double fx1 = coeff[0] * a->x + coeff[1] * a->y - coeff[2];
    double fx2 = coeff[0] * b->x + coeff[1] * b->y - coeff[2];
    if ((fx1 * fx2) > 0)
        return true;
    return false;
}

/**
 * This function is used to get the notches present in a face.
 * @param face This is face for which we will want the list of notches.
 * @return It returns a set of vertices which are all the notches present on the face.
 */
std::set<Vertex *> get_notches(Face *face)
{
    std::vector<Vertex *> vertices = face->enumerate_all_vertices();
    std::set<Vertex *> notches;

    int n = vertices.size();
    for (int i = 0; i < n; i++)
    {
        int pre = (i - 1 + n) % n;
        int nxt = (i + 1) % n;
        if (angle(vertices[pre], vertices[i], vertices[nxt]) > 180)
            notches.insert(vertices[i]);
    }

    return notches;
}

/**
 * This function is used to retrieve the next vertex to a given vertex on a given face.
 * @param v This is the vertex for which we need the next vertex.
 * @param f This is the face on which we want the next vertex.
 * @return It returns the vertex that is after vertex v on the face f.
 */
Vertex *getNextVertex(Vertex *v, Face *f)
{
    Vertex *u = NULL;
    HalfEdge *temp = f->edge;
    do
    {
        if (temp->org == v)
            u = temp->twin->org;
        temp = temp->nxt;
    } while (temp != f->edge);

    assert(u != NULL);
    return u;
}

/**
 * This function is used to retrieve the previous vertex to a given vertex on a given face.
 * @param v This is the vertex for which we need the previous vertex.
 * @param f This is the face on which we want the next vertex.
 * @return It returns the vertex that is before vertex v on the face f.
 */
Vertex *getPrevVertex(Vertex *v, Face *f)
{
    Vertex *u = NULL;
    HalfEdge *temp = f->edge;
    do
    {
        if (temp->nxt->org == v)
            u = temp->org;
        temp = temp->nxt;
    } while (temp != f->edge);

    assert(temp != NULL);
    return u;
}

/**
 * This function is used to check if three points are collinear.
 * @param v1 This is the first vertex.
 * @param v2 This is the second vertex.
 * @param v3 This is the third vertex.
 * @return It returns true if the three points are collinear and false otherwise.
 */
bool isLinear(Vertex *v1, Vertex *v2, Vertex *v3)
{
    return abs((v2->y - v1->y) / (v2->x - v1->x) - (v3->y - v2->y) / (v3->x - v2->x)) < 1e-8;
}